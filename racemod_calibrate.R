library(foreign)
library(data.table)
library(sf)
library(ggplot2)
library(mgcv)

if (grepl('results', getwd())) {
  rootdir =  "C:/Mathis/ICSL/flood_vulnerability"
} else{
  rootdir = gsub("/src.*","",getwd())
}
datadir = file.path(rootdir, 'data')
resdir = file.path(rootdir, 'results')
setwd(resdir)

#TO DO:
# - Test keeping only those names with same address 
# - Test keeping name only once within the same PolyID
# - Automatize table making of data inspection

#----------------------------------- Import data ------------------------------------------------
#Individual landowners' race/ethnicity preds from census model
taxroll_censusmod <- read.csv('parcel_taxrollname_residindiv_pred_census_ln.csv')
taxroll_pred$censusmod_sum <- with(taxroll_censusmod, api+black+hispanic+white)
#qplot(taxroll_pred$censusmod_sum)
#Individual landowners' race/ethnicity preds from Florida registration model
taxroll_flreg <- read.csv('parcel_taxrollname_residindiv_pred_flreg_name.csv')

#Parcel-level race/ethnicity predictions - all models
parcel_pred <- read.csv('parcels_blocksfill_racepred.csv', 
                        colClasses= c('character', 'character', rep('numeric', 41), 'character', 'numeric',
                                      'character', rep('numeric', 6), 'character', 'numeric'))
parcel_pred$censusmod_sum <- with(parcel_pred, api+black+hispanic+white)
#qplot(parcel_pred$censusmod_sum)

#Blockgroup-level race/ethnicity predictions - all models
bg_pred <- read.dbf('blockgroup_racepred.dbf')
bg_pred$censusmod_sum <- with(bg_pred, api+black+hispanic+white)
#qplot(bg_pred$censusmod_sum)
bg_pred <- bg_pred[bg_pred$PARCELPOP_>0,]
#str(bg_pred)

#Tract-level race/ethnicity predictions - all models
t_pred <- read.dbf('tract_racepred.dbf')
t_pred$censusmod_sum <- with(t_pred, api+black+hispanic+white)
#qplot(t_pred$censusmod_sum)
t_pred <- t_pred[t_pred$PARCELPOP_>0 & t_pred$white>0 & t_pred$censusmod_sum>0,]
#str(t_pred)

#Get county codes
WAparceldb <- file.path(datadir, 'WAParcel/StatewideParcels_v2012_e9.2_r1.3/StatewideParcels_v2012_e9.2_r1.3.gdb')
dataproviders <- st_read(dsn=WAparceldb,layer="DataProvider")

#Taxroll record (after removal of duplicate TaxRollIDs) joined to name
vulgdb <- 'flood_vulnerability.gdb'
parcel_taxrollname <- st_read(dsn=vulgdb,layer="parcel_taxrollname")

#After examination, remove items and collect garbage

##############################################################################################################
##----------------------------------- Examine and format data ------------------------------------------------
##############################################################################################################
##----------- Assess number of parcels and population with race/ethnicity predictions ------------------------
#Total number of parcel-blocks intersections
parcel_pred <- setDT(parcel_pred)

#Total number of parcel-blocks intersections kept in spatial parcel database
parcel_pred[!is.na(TAXROLLNUM),.N]
#Total number of parcels in spatial database 
parcel_pred[!is.na(TAXROLLNUM), uniqueN(PolyID)]
#Total population in spatial parcel database
parcel_predsub <- parcel_pred[PARCELPOP>0 & !is.na(PARCELPOP),]
parcel_predsub[,sum(PARCELPOP)]

#Total number of parcels with population
parcel_predsub[, .N]
parcel_predsub[, uniqueN(PolyID)]

#Total number of parcel-block intersections with population and a taxroll record
parcel_predsub[TAXROLLNUM>0, .N]
#Why TAXROLLNUM == 0?
notaxroll <- parcel_predsub[TAXROLLNUM==0 | is.na(TAXROLLNUM),]
  #Because not in taxroll record in the first place (e.g. Cowlitz, Stevens, etc.) - see flood_risk_WA_format.py l349
countyname_notaxroll <- dataproviders[dataproviders$Abbreviation %in% c('Cowlitz', 'Lewis', 'Stevens', 'Jefferson', 'San Juan'),
                                  'DataProviderID']
county_notaxroll <- notaxroll[substr(PolyID,1,3) %in% countyname_notaxroll,] #93,465
  #Because not a residential land use and so was not included 
      #consider including by changing flood_risk_WA_format.py l353 to general taxroll database so as to include owner name
notaxroll[!(substr(PolyID,1,3) %in% countyname_notaxroll) & PolyID %in% parcel_taxrollname$PolyID, .N] #48,624
  #Because census block that does not intersect any parcel
notaxroll[PolyID == ' ', .N] #2,674 Not NA.. will be changed to 99900000000+
  #Because 0 or NA StateLandUseCD + no land owner name associated with parcel
notaxroll_error <- notaxroll[!(substr(PolyID,1,3) %in% countyname_notaxroll) & 
                               !(PolyID %in% parcel_taxrollname$PolyID) &
                               PolyID != ' ',]
  #Because erroneously deleted when looking at duplicate PolyIDs in taxroll record? Correct, check again?

#Total population living in a parcel with taxroll record
parcel_predsub[TAXROLLNUM>0,sum(PARCELPOP)]

#Total number of parcel-block intersections with population, a taxroll record, and a name that could be analyzed
parcel_predsub[TAXROLLNUM>0 & !is.na(TaxRollIDCount), .N]

ggplot(parcel_predsub[abs(TAXROLLNUM-TaxRollIDCount)>0 & !is.na(TaxRollIDCount),],
       aes(x=TAXROLLNUM-TaxRollIDCount)) + geom_histogram() + scale_y_sqrt()
morenames <- parcel_predsub[(TAXROLLNUM-TaxRollIDCount)<0 & !is.na(TaxRollIDCount),]
#Not sure why some records have different number

#Population living in parcel with a name that could be analyzed
parcel_predsub[TAXROLLNUM>0 & !is.na(TaxRollIDCount), sum(PARCELPOP)]

#Average percentage of taxroll records per parcel that had a name to analyze for race/ethnicity prediction
parcel_predsub[TAXROLLNUM>0 & !is.na(TaxRollIDCount), 100*mean(TaxRollIDCount/TAXROLLNUM)]

#For each model, percentage of taxroll records and population that has name predictions
parcel_predsub[TAXROLLNUM>0 & !is.na(white), c(.N, sum(PARCELPOP))] 
parcel_predsub[TAXROLLNUM>0 & !is.na(pctwhite), c(.N, sum(PARCELPOP))] 
parcel_predsub[TAXROLLNUM>0 & !is.na(GreaterEuropean.WestEuropean.French_wikiln), c(.N, sum(PARCELPOP))] 
parcel_predsub[TAXROLLNUM>0 & !is.na(GreaterEuropean.WestEuropean.French), c(.N, sum(PARCELPOP))] 
parcel_predsub[TAXROLLNUM>0 & !is.na(nh_white), c(.N, sum(PARCELPOP))] 

#------- Summary statistics by block group
parcel_predsub[, .(.I[!is.na(white)])/.N, by=GEOID10_bg] #Percentage of parcels, population, and TaxRoll records with name prediction per block group



#------- Summary statistics by tract


#-------------------------------------------------------------------------

#Compare parcel aggregated population to blockgroup population estimates
ggplot(bg_pred, aes(x=B02001e1, y=PARCELPOP_)) + 
  geom_point() + 
  geom_smooth()
summary(lm(B02001e1~PARCELPOP_, data=bg_pred))

#Compare parcel-aggregated population to tract population
ggplot(t_pred, aes(x=DP0080001, y=PARCELPOP_)) + 
  geom_point() + 
  geom_smooth()
max(with(t_pred, abs(DP0080001-PARCELPOP_)), na.rm=T)

#Check number of parcels taken in account to determine race composition in blockgroup
qplot(bg_pred$TaxRollIDC/bg_pred$TAXROLLNUM)
bg_pred_sub <- bg_pred[bg_pred$TaxRollIDC/bg_pred$TAXROLLNUM>0.90 & bg_pred$TaxRollIDC>500,]


##----------------------------------- Analyze blockgroup data ------------------------------------------------
#Check predictions for white population
ggplot(bg_pred_sub, aes(x=B02001e2/B02001e1, y=white)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)

bg_pred_sub$census_whiteper <- with(bg_pred_sub, B02001e2/B02001e1)
summary(lm(census_whiteper~white, data=bg_pred_sub))

bg_pred_sub$wikiwhite <- with(bg_pred_sub, British+EastEurope+Jewish+French+Germanic+Italian+Nordic)
ggplot(bg_pred_sub, aes(x=B02001e2/B02001e1, y=wikiwhite)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)
summary(lm(census_whiteper~wikiwhite, data=bg_pred_sub))

ggplot(bg_pred_sub, aes(x=white, y=wikiwhite)) + 
  geom_point() 
summary(lm(white~wikiwhite, data=bg_pred_sub))

ggplot(bg_pred_sub, aes(x=B02001e2/B02001e1, y=nh_white)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)
summary(lm(census_whiteper~nh_white, data=bg_pred_sub))


#Check predictions for black population
ggplot(bg_pred_sub, aes(x= B02001e3/B02001e1, y=black)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)

bg_pred_sub$blacktot <- with(bg_pred_sub, black*B02001e1)
bg_pred_sub$census_blackper <- with(bg_pred_sub, B02001e3/B02001e1)
summary(lm(census_blackper~black, data=bg_pred_sub))

ggplot(bg_pred_sub, aes(x=B02001e3/B02001e1, y=nh_black)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)
summary(lm(census_blackper~nh_black, data=bg_pred_sub))

#Check predictions for hispanic population
ggplot(bg_pred_sub, aes(x=B03002e12/B03002e1, y=hispanic)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)

bg_pred_sub$census_hispanicper <- with(bg_pred_sub, B03002e12/B03002e1)
summary(lm(census_hispanicper~hispanic, data=bg_pred_sub))

ggplot(bg_pred_sub, aes(x=B03002e12/B03002e1, y=hispanic_f)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)
summary(gamm(census_hispanicper~hispanic_f, data=bg_pred_sub))
hispflreg <- mgcv::gam(B03002e12/B03002e1~s(hispanic_f), family=gaussian(link='identity'),
                       data= bg_pred_sub)
summary(hispflreg)

##----------------------------------- Analyze census tract data ------------------------------------------------
#Check predictions for white population
t_pred$census_whiteper <- with(t_pred, DP0090001/DP0080001)

ggplot(t_pred, aes(x=DP0090001/DP0080001, y=white)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)
summary(lm(census_whiteper~white, data=t_pred))

ggplot(t_pred, aes(x=DP0090001/DP0080001, y=nh_white)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)
summary(lm(census_whiteper~nh_white, data=t_pred))

#Check predictions for white population
t_pred$census_blackper <- with(t_pred, DP0090002/DP0080001)

ggplot(t_pred, aes(x=census_blackper, black)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)
summary(lm(census_blackper~black, data=t_pred))

ggplot(t_pred, aes(x=census_blackper, nh_black)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)
summary(lm(census_blackper~nh_black, data=t_pred))

ggplot(t_pred, aes(x=census_blackper, pctblack/100)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)
summary(lm(census_blackper~pctblack, data=t_pred))

#Check predictions for hispanic population
t_pred$census_hispper <- with(t_pred,   DP0110002/DP0080001)

ggplot(t_pred, aes(x=census_hispper, hispanic)) + 
  geom_point() + 
  geom_smooth() +
  geom_abline(slope=1)
summary(lm(census_hispper~hispanic, data=t_pred))
