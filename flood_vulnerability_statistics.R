library(sf)
library(data.table)
library(plyr)
library(ggplot2)
library(gridExtra)
library(ggrepel)
library(stringr)
library(extrafont)
library(hrbrthemes)
library(VennDiagram)
library(ggtern)
library(kableExtra)
library(extrafont)
#font_import()
loadfonts(device = "win")

if (grepl('results', getwd())) {
  rootdir =  "C:/Mathis/ICSL/flood_vulnerability"
} else{
  rootdir = gsub("/src.*","",getwd())
}
datadir = file.path(rootdir, 'data')
resdir = file.path(rootdir, 'results')
figdir = file.path(resdir, 'figures')
setwd(resdir)

#----------------------------------- Define functions ------------------------------------------------
#Compute percentages for each race for a given model
summod <- function(dt, mod, ref, byc=NULL) {
  races <- unique(gsub(paste0('_',mod,'.*'), '',
                       grep(mod, colnames(dt), value=T)))
  ldply(races, function(race) {
    popcol = grep(paste0(race, '.*', mod, '.*_pop$'), colnames(p_attri), value=T)
    floodcol = grep(paste0(race, '.*', mod, '.*_popflood$'), colnames(p_attri), value=T)
    femacol = grep(paste0(race, '.*', mod, '.*_popFEMA$'), colnames(p_attri), value=T)
    varn <- c('per','floodper','FEMAper')
    statsdt <- p_attri[, c(sum(get(popcol), na.rm=T)/sum(get(paste0(ref, '_pop')), na.rm=T),
                           sum(get(floodcol), na.rm=T)/sum(get(paste0(ref, '_popflood')), na.rm=T),
                           sum(get(femacol), na.rm=T)/sum(get(paste0(ref, '_popfema')), na.rm=T)), by=byc]
    if (is.null(byc)) {
      statsdt <- data.table(bycol=rep('total', length(statsdt)), statsdt)
    }
    statsdt <- cbind(varn, statsdt, race, mod)
    paste0(race,'_',mod,'per')
    return(setDT(statsdt))
  })
}

#Build function for basic multiplot with weighted mean and quantile regression
multiplot <- function(dat, xvar, yvar, weightvar, facetvar) {
  p <- ggplot(dat, aes_string(x=xvar, y=yvar)) + 
    geom_point(alpha=1/2) + 
    geom_smooth(color='red', method='lm', mapping = aes_string(weight = weightvar)) +
    geom_quantile(quantiles=c(0.1, 0.25, 0.5, 0.75, 0.9), color='orange',
                  aes_string( mapping = weightvar)) +
    scale_y_log10() +
    facet_grid(~get(facetvar), scales = 'free_x') +
    theme_classic() +
    theme(axis.title =element_text(size=16),
          strip.text = element_text(size=16),
          strip.background = element_rect(colour="white"),
          text = element_text(size=16))
  print(p)
}

#----------------------------------- Import data ------------------------------------------------
gdb <- 'flood_risk.gdb'
#Read parcel-level data 
p_attri <- st_read(dsn=gdb,layer="parcel_blocks_fill_flood_attri")
p_attri <- setDT(p_attri)
p_attri <- p_attri[FEMAFloodStatus == 1 & is.na(FEMAStudyStatus), FEMAFloodStatus := 0]
p_attri <- p_attri[is.na(FEMAStudyStatus), FEMAStudyStatus := 0]

#Read census block-level analysis data
b_attri <- st_read(dsn=gdb,layer="blockurbanflood_diss")
b_attri <- setDT(b_attri)
#Read census trast-level data
t_attri <- st_read(dsn=gdb, layer="tracts_floodfinal")
t_attri <- setDT(t_attri)
#Read block-group census data
bg <- st_read(file.path(datadir, 'TIGER2017/2010_ACS_5YR_BG_53_WASHINGTON.gdb'), layer = 'ACS_10_5YR_BG_53_WASHINGTON')

#Get Venn diagram colors
Venncol <- read.csv('figures/VennColors.csv')

#Import SVI data
SVI <- read.csv(file.path(datadir, 'SVI/Washington_03242014.csv'))
SVI$FIPS <- as.factor(SVI$FIPS)

#----------------------------------- Results analysis ------------------------------------------------
#Total number of people
p_attri[,sum(PARCELPOP, na.rm=T)]
b_attri[,sum(POP10, na.rm=T)]
#Number of people living within flood zone as predicted with FEMA flood hazard data at census block level
b_attri[,sum(FEMAPOP_B, na.rm=T)]
#Number of people living within flood zone as predicted with FEMA flood hazard data at parcel level
p_attri[,sum(FEMApop, na.rm=T)]
#Number of people living within flood zone as predicted with FATHOM flood hazard data at census block level
b_attri[,sum(FLOODPOP_B, na.rm=T)]
#Number of people living within flood zone as predicted with FATHOM flood hazard data at parcel level
p_attri[,sum(floodpop, na.rm=T)]

#Compute flood ratios at state level
p_attri[,(sum(hisp_BISG_popflood,na.rm=T)/sum(census_popflood,na.rm=T))/(sum(hisp_BISG_pop,na.rm=T)/sum(census_pop,na.rm=T))]
p_attri[,(sum(black_BISG_popflood,na.rm=T)/sum(census_popflood,na.rm=T))/(sum(black_BISG_pop,na.rm=T)/sum(census_pop,na.rm=T))]
p_attri[,(sum(asi_BISG_popflood,na.rm=T)/sum(census_popflood,na.rm=T))/(sum(asi_BISG_pop,na.rm=T)/sum(census_pop,na.rm=T))]
p_attri[,(sum(white_BISG_popflood,na.rm=T)/sum(census_popflood,na.rm=T))/(sum(white_BISG_pop,na.rm=T)/sum(census_pop,na.rm=T))]

#------------- Histogram of total and flood percentage by race + flood ratio, at tract level -----------------------
t_attri_BISGmelt <- melt(t_attri[!is.na(SUM_last_popflood) & SUM_last_popflood>0,], id.vars = 'GEOID10_t', 
                         measure.vars = grep('BISG_per', colnames(t_attri), value=T))
t_attri_BISGmelt[,category := '% of total population']

t_attri_BISGfloodmelt <- melt(t_attri[!is.na(SUM_last_popflood) & SUM_last_popflood>0,], id.vars = 'GEOID10_t', 
                              measure.vars = grep('BISG_floodper', colnames(t_attri), value=T))
t_attri_BISGfloodmelt[,`:=`(category = '% of population in flood zone',
                            variable = gsub('flood', "", variable))]
t_attri_BISG <- rbind(t_attri_BISGmelt, t_attri_BISGfloodmelt)

facet_names1 <- c(
  `white_BISG_per` = "Non-hispanic white population",
  `hisp_BISG_per` = "Hispanic population",
  `black_BISG_per` = "Non-hispanic black population",
  `asi_BISG_per` = "Asian population"
)

ggplot(t_attri_BISG[(variable != c('oth_BISG_per')),]) + 
  geom_histogram(aes(x=value, y = stat(count / sum(count)), fill=category), alpha=1/2, position='identity') +
  scale_x_percent(name = '') + 
  scale_y_percent(name = 'Percent of census tracts') + 
  scale_fill_manual(values = c('#7570b3', '#d95f02'), labels = function(x) str_wrap(x, width = 40)) +
  facet_wrap(~ variable, ncol = 1, scales = "free_y", labeller = as_labeller(facet_names1)) + 
  theme_ipsum_rc() + 
  theme(legend.title = element_blank(),
        legend.position="bottom")

t_attri_BISGratiomelt <- melt(t_attri[!is.na(SUM_last_popflood) & SUM_last_popflood>0,], id.vars = 'GEOID10_t', 
                              measure.vars = grep('BISG_floodratio', colnames(t_attri), value=T))
facet_names2 <- c(
  `white_BISG_floodratio` = "Non-hispanic white population",
  `hisp_BISG_floodratio` = "Hispanic population",
  `black_BISG_floodratio` = "Non-hispanic black population",
  `asi_BISG_floodratio` = "Asian population"
)

t_attri_BISGratiomelt[, category := ifelse(value<=1, 'negative', 'positive')]

#Check weighted average of flood ratio
t_attri_BISGcast <- dcast(t_attri_BISG, GEOID10_t+variable~category, value.var = 'value')
setnames(t_attri_BISGcast, old= c('% of population in flood zone','% of total population'), new = c('floodper', 'per'))
t_attri_BISGcast <- t_attri_BISGcast[t_attri, on='GEOID10_t']
t_attri_BISGcast[, `:=`(floodratio = floodper/per,
                        racepop = per*SUM_last_pop)]
#Weighted average of flood ratio by flooded population of each race in bg
t_attri_BISGcast[,sum(floodratio*floodper*SUM_last_popflood, na.rm=T)/sum(floodper*SUM_last_popflood, na.rm=T), by=variable]
#Weighted average of flood ratio by total population of each race in bg
t_attri_BISGcast[,sum(floodratio*racepop, na.rm=T)/sum(racepop, na.rm=T), by=variable]
#Weighted average of flood ratio by total flooded population in bg
t_attri_BISGcast[,sum(floodratio*SUM_last_popflood, na.rm=T)/sum(SUM_last_popflood, na.rm=T), by=variable]
#Weighted average of flood ratio by total population in bg
t_attri_BISGcast[,sum(floodratio*SUM_last_pop, na.rm=T)/sum(SUM_last_pop, na.rm=T),  by=variable]

#------------- Weighted violin of total and flood percentage by race + flood ratio, at tract level -----------------------
leglabels1 <- c("Non-hispanic white population",
                "Hispanic population",
                "Non-hispanic black population",
                "Asian population")
ggplot(t_attri_BISGratiomelt[variable != 'oth_BISG_floodratio',],
       aes(x=variable, y=value, fill=variable, color=variable)) +
  geom_jitter(height = 0, width = 0.1, alpha=1/20, color='black') +
  geom_violin(alpha=1/1.5, draw_quantiles = c(0.25, 0.5, 0.75)) + 
  geom_hline(yintercept=1) + 
  scale_x_discrete(name = '', labels= str_wrap(leglabels1, width=17)) + 
  scale_y_continuous(name = 'Flood risk representativity ratio',
                     limits=c(0,10), breaks = c(0,0.2,0.5,0.8,1,1.25,1.5,2,5, 10)) + 
  scale_fill_discrete(name = 'Flood risk representativity ratio', labels= leglabels1) + 
  scale_color_discrete(name = 'Flood risk representativity ratio', labels= leglabels1) +
  #scale_y_sqrt(breaks = c(0,0.1,0.2,0.5,1,1.5,2,5,10,20,40)) + 
  theme_ipsum_rc() +
  theme(panel.grid.minor = element_blank(),
        legend.position = 'None')

#------------- Lollipop graph of total and flood percentage by race x models x parcel vs. block, at state level -----------------------
#Pre-process parcel-level data
t_attri_ratiomelt <- melt(t_attri[!is.na(SUM_last_popflood) & SUM_last_popflood>0,], id.vars = 'GEOID10_t', 
                          measure.vars = grep('_floodratio', colnames(t_attri), value=T))

p_attri[, urbanrural := ifelse(is.na(NAME10), 'rural', 'urban')] 

wastats_tot <- summod(p_attri, mod='BISG', 'last')
setnames(wastats_tot, 2, 'urbanrural')
wastats <- setDT(rbind(wastats_tot, summod(p_attri, mod='BISG', 'last', byc='urbanrural')))
setnames(wastats, old='V1', new='stats')

wastats[, varn := factor(varn, levels=c('per', 'floodper', 'FEMAper'))]
wastats[,`:=`(segmin = min(stats), segmax = max(stats)), by = .(urbanrural, race)]
wastats$level <- 'parcel'

#Pre-process block-level data
wastats_t <- t_attri[, c(white_censusper = sum(DP0110011)/sum(DP0080001),
                         white_censusfloodper = sum(SUM_FLOODPOP_B*DP0110011/DP0080001, na.rm=T)/sum(SUM_FLOODPOP_B, na.rm=T),
                         white_censusFEMAper = sum(SUM_FEMAPOP_B*DP0110011/DP0080001, na.rm=T)/sum(SUM_FEMAPOP_B, na.rm=T),
                         black_censusper = sum(DP0110012)/sum(DP0080001),
                         black_censusfloodper = sum(SUM_FLOODPOP_B*DP0110012/DP0080001, na.rm=T)/sum(SUM_FLOODPOP_B, na.rm=T),
                         black_censusFEMAper = sum(SUM_FEMAPOP_B*DP0110012/DP0080001, na.rm=T)/sum(SUM_FEMAPOP_B, na.rm=T),
                         hisp_censusper = sum(DP0110002)/sum(DP0080001),
                         hisp_censusfloodper = sum(SUM_FLOODPOP_B*DP0110002/DP0080001, na.rm=T)/sum(SUM_FLOODPOP_B, na.rm=T),
                         hisp_censusFEMAper = sum(SUM_FEMAPOP_B*DP0110002/DP0080001, na.rm=T)/sum(SUM_FEMAPOP_B, na.rm=T),
                         asi_censusper = sum(DP0110014+ DP0110015)/sum(DP0080001),
                         asi_censusfloodper = sum(SUM_FLOODPOP_B*(DP0110014+DP0110015)/DP0080001, na.rm=T)/sum(SUM_FLOODPOP_B, na.rm=T),
                         asi_censusFEMAper = sum(SUM_FEMAPOP_B*(DP0110014+DP0110015)/DP0080001, na.rm=T)/sum(SUM_FEMAPOP_B, na.rm=T)),]
wastats_tformat <- data.table(stats = wastats_t, 
                              race = gsub('_census.*', '', names(wastats_t)), 
                              varn = gsub('(.*_census)', '', names(wastats_t)))
wastats_tformat[,`:=`(segmin = min(stats),
                      segmax = max(stats)), by = race]
wastats_tformat$level <- 'block'

wastats_join <- rbind(wastats, wastats_tformat, fill=TRUE)
wastats_join[, `:=`(varn = factor(varn, levels=c('per', 'floodper', 'FEMAper')),
                    race = factor(race, levels=unique(setorder(wastats_join[level == 'parcel',], stats)$race)))]


legtitle <- ''
leglabels2 <- c('In total', 'Living in flood zone (FATHOM data)','Living in flood zone (FEMA data)')
update_geom_font_defaults(family = "Arial Narrow", face = "plain",
                          size = 3.5, color = "#2b2b2b")

parcelblock_lollipop <- ggplot(wastats_join[urbanrural %in% c('total',NA) & race != 'oth',]) +
  geom_linerange( aes(x=race, ymin=segmin, ymax=segmax, group=level), 
                  color='black', position= position_dodge(width=0.5)) +
  geom_point(aes(x=race, y=stats, color=varn, shape=varn, group=level), 
             size=3, alpha=3/4, position= position_dodge(width=0.5)) +
  geom_text_repel(aes(x=race, y=stats, label=paste0(round(100*stats,0),'%'), color=varn, group=level), 
                  vjust = 0, angle=0, position= position_dodge(width=1),
                  max.iter=20000, direction="x", segment.alpha = 0, xlim = c(0,90)) +
  annotate('text', x = c(Inf, Inf), y = c(-Inf,-Inf), vjust = c(6.5,9), hjust = c(-0.12,-0.1),
           label=c('parcel-level assessment', 'block/tract-level assessment')) +
  scale_y_percent(name='Percentage of the Washington state population', limits=c(0,1), expand=c(0,0)) +
  scale_x_discrete(name = 'Race-Ethnicity',
                   labels= gsub('\\s*population\\s*', '', as.character(rev(leglabels1)))) +
  scale_color_manual(name = legtitle, labels= leglabels2, values = c('#8c510a', '#01665e', '#542788')) +
  scale_shape(name = legtitle, labels= leglabels2) + 
  coord_flip() +
  theme_bw() +
  theme(panel.border = element_blank(),
        legend.position = c(0.65,0.20),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.line = element_line(color='black'))

urbanrural_lollipop <-ggplot(wastats_join[level == 'parcel' & urbanrural %in% c('rural','urban') & race != 'oth',]) +
  geom_linerange( aes(x=race, ymin=segmin, ymax=segmax, group=urbanrural), 
                  color='black', position= position_dodge(width=0.5)) +
  geom_point(aes(x=race, y=stats, color=varn, shape=varn, group=urbanrural), 
             size=3, alpha=3/4, position= position_dodge(width=0.5)) +
  geom_text_repel(aes(x=race, y=stats, label=paste0(round(100*stats,0),'%'), color=varn, group=urbanrural), 
                  vjust = 0, angle=0, position= position_dodge(width=1),
                  max.iter=20000, direction="x", segment.alpha = 0, xlim = c(0,90)) +
  annotate('text', x = c(Inf, Inf), y = c(-Inf,-Inf), vjust = c(6.5,9), hjust = c(-0.12,-0.1),
           label=c('Urban areas', 'Rural areas')) +
  scale_y_percent(name='Percentage of the Washington state population', limits=c(0,1), expand=c(0,0)) +
  scale_x_discrete(name = 'Race-Ethnicity',
                   labels= gsub('\\s*population\\s*', '', as.character(rev(leglabels1)))) +
  scale_color_manual(name = legtitle, labels= leglabels2, values = c('#8c510a', '#01665e', '#542788')) +
  scale_shape(name = legtitle, labels= leglabels2) + 
  coord_flip() +
  theme_bw() +
  theme(panel.border = element_blank(),
        legend.position = c(0.65,0.20),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.line = element_line(color='black'))

grid.arrange(parcelblock_lollipop, urbanrural_lollipop)

#------------- Correlate block-group individual wealth and race indicators to flood ratios --------------------------------------------------------------
# poverty status B17021e1
# median household income B19013e1
# owner-occupied housing units median value (B25077e1)
# ratio of income to poverty level in past 12 months (C17002e1)
# contract rent/with cash rent (B25056e2)
wastats_bg <- setDT(summod(p_attri, mod='BISG', 'last', byc='GEOID10_bg'))
setnames(wastats_bg, old='V1', new='stats')
wastats_bgj <- wastats_bg[setDT(as.data.frame(bg)[,c('GEOID10', 'B17021e1', 'B19013e1', 'B25077e1', 'C17002e1', 'B25056e2')]),
                         on= 'GEOID10_bg==GEOID10']
wastats_bgj <- wastats_bgj[!is.na(varn),]

#Compute average of state-standardized rent and house prise
wastats_bgj[, `:=`(housing_standardized = B25077e1/mean(B25077e1, na.rm = T),
                  rent_standardized = B25056e2/mean( B25056e2, na.rm = T))]
wastats_bgj[, real_standardized := rowMeans(cbind(housing_standardized, rent_standardized), na.rm=T)]

castf <- as.formula(
  paste(
    paste(colnames(wastats_bgj)[!(colnames(wastats_bgj) %in% c('varn','value', 'variable', 'stats'))], collapse = ' + '),
    '~ varn'))

wastats_bgcast <- dcast(wastats_bgj, castf, value.var = 'stats')
wastats_bgcast[, `:=`(floodratio = floodper/per,
                      FEMAratio = FEMAper/per)]

#Check distribution of block group's total population and each race's population
wastats_bgcast <- wastats_bgcast[setDT(bg)[, c('GEOID10', 'B01001e1'), with=FALSE], on='GEOID10_bg==GEOID10']
wastats_bgcast <- wastats_bgcast[p_attri[, .(last_pop = sum(last_pop, na.rm=T),
                                             last_popflood = sum(last_popflood, na.rm=T),
                                             last_poper = sum(last_popflood, na.rm=T)/sum(last_pop, na.rm=T)),
                                         by='GEOID10_bg'], on='GEOID10_bg']
wastats_bgcast[, racepop := per*last_pop]
wastats_bgcast <- wastats_bgcast[!is.na(race),]

ggplot(wastats_bgcast, aes(x=racepop)) + 
  geom_histogram() + 
  scale_y_log10() +
  scale_x_continuous(breaks = seq(0,4000,200)) +
  facet_wrap(~race, nrow=5) +
  theme_ipsum()

ggplot(bg, aes(x=population)) + 
  geom_histogram() + 
  scale_y_log10() +
  scale_x_continuous(breaks = seq(0,4000,200)) +
  theme_ipsum()

#Weighted average of flood ratio by flooded population of each race in bg
wastats_bgcast[,sum(floodratio*floodper*last_popflood, na.rm=T)/sum(floodper*last_popflood, na.rm=T), by='race']
wastats_bgcast[,sum(floodper*last_popflood, na.rm=T), by=c('race')]
#Weighted average of flood ratio by total population of each race in bg
wastats_bgcast[,sum(floodratio*racepop, na.rm=T)/sum(racepop, na.rm=T), by='race']
#Weighted average of flood ratio by total flooded population in bg
wastats_bgcast[,sum(floodratio*last_popflood, na.rm=T)/sum(last_popflood, na.rm=T), by='race']
#Weighted average of flood ratio by total population in bg
wastats_bgcast[,sum(floodratio*last_pop, na.rm=T)/sum(last_pop, na.rm=T), by='race']

#Check correlation with percentage population of each race in block group
multiplot(wastats_bgcast[racepop != 0,], 
          xvar='per', yvar='floodratio', weightvar='racepop', facetvar = 'race')

#Check correlation with percentage population in flood zone in block group
multiplot(wastats_bgcast[racepop != 0,], 
          xvar='last_poper', yvar='floodratio', weightvar='racepop', facetvar = 'race')

#Check correlation with median household income (B19013e1)
multiplot(wastats_bgcast[racepop != 0,],
          xvar='B19013e1', yvar='floodratio', weightvar='racepop', facetvar = 'race')

#Check correlation with ratio of income to poverty level in past 12 months
multiplot(wastats_bgcast[racepop != 0,],
          xvar='C17002e1', yvar='floodratio', weightvar='racepop', facetvar = 'race')

#Check correlation with real estate standardized index 
#(average of statewide-standardized rent and house prices)
multiplot(wastats_bgcast[racepop != 0,],
          xvar='real_standardized', yvar='floodratio', weightvar='racepop', facetvar = 'race')

#------------- Venn diagram of flooded population FATHOM and FEMA showing total population and flood ratio for different races --------------------------------------------------------------
popstats <- p_attri[,sum(PARCELPOP, na.rm=T), by=c('FloodStatus', 'FEMAFloodStatus', 'FEMAStudyStatus')]
setnames(popstats, 'V1', 'pop')

#FEMA study - FEMA flood Venn
grid.newpage()
draw.pairwise.venn(round(popstats[FEMAStudyStatus==1, sum(pop)])/1000,
                   round(popstats[FEMAFloodStatus==1, sum(pop)])/1000,
                   round(popstats[FEMAFloodStatus==1, sum(pop)])/1000,
                   category = c("Population within FEMA-assessed area",
                                "Population within FEMA flood zone"), 
                   lty = rep("blank",2), 
                   fill = c("light blue", "darkblue"), 
                   alpha = rep(0.5, 2), 
                   cat.pos = c(0,0), 
                   cat.dist = rep(0.025, 2))

#FEMA flood- FATHOM flood Venn
grid.newpage()
draw.pairwise.venn(round(popstats[FEMAFloodStatus==1, sum(pop)])/1000,
                   round(popstats[FloodStatus==1, sum(pop)])/1000,
                   round(popstats[FloodStatus==1 & FEMAFloodStatus==1, sum(pop)])/1000,
                   category = c("Population within FEMA flood zone",
                                "Population within FATHOM flood zone"), 
                   lty = rep("blank",2), 
                   fill = c("light blue", "darkblue"), 
                   alpha = rep(0.5, 2), 
                   cat.pos = c(0,0), 
                   cat.dist = rep(0.025, 2))

#FEMA study - FATHOM flood
grid.newpage()
draw.pairwise.venn(round(popstats[FEMAStudyStatus==1, sum(pop)])/1000,
                   round(popstats[FloodStatus==1, sum(pop)])/1000,
                   round(popstats[FloodStatus==1 & FEMAStudyStatus==1, sum(pop)])/1000,
                   category = c("Population within FEMA-assessed area",
                                "Population within FATHOM flood zone"), 
                   lty = rep("blank",2), 
                   fill = c("light blue", "darkblue"), 
                   alpha = rep(0.5, 2), 
                   cat.pos = c(0,0), 
                   cat.dist = rep(0.025, 2))

#Make table of stats for full circles (e.g. all population in FATHOM flood zone vs not)
fullkablestats <- function(col) {
  stats <- setDT(summod(p_attri, mod='BISG', 'last', byc=col))
  stats2 <- dcast(stats[varn=='per',], get(col)~race, value.var = 'V1') 
  popstats <- p_attri[,.(pop = sum(PARCELPOP, na.rm=T)), by=col]
  stats2 <- stats2[popstats, on=paste0('col==',col)]
  stats2$varn <- col
  return(stats2)
}

allstats <- setDT(summod(p_attri, mod='BISG', 'last', byc=NULL))
allstats_format <- cbind(col='1',
                         dcast(allstats[varn=='per',], varn~race, value.var = 'V1'), 
                         pop=p_attri[, sum(PARCELPOP, na.rm=T)]) 
allstats_format[,(cols):=lapply(.SD, function(x) 100*round(x, 2)), .SDcols = cols]
allstats_format[, pop:=round(pop)]
setcolorder(allstats_format, c('varn','col','pop',cols))

wastats_floodsrc2 <- rbind(fullkablestats('FEMAStudyStatus'),
                           fullkablestats('FEMAFloodStatus'),
                           fullkablestats('FloodStatus'))
wastats_floodsrc2[,(cols):=lapply(.SD, function(x) 100*round(x, 2)), .SDcols = cols]
wastats_floodsrc2[, pop:=round(pop)]
setcolorder(wastats_floodsrc2, c('varn','col','pop',cols))

kable(rbind(allstats_format, wastats_floodsrc2)) %>%
  kable_styling("striped", full_width = F) %>%
  save_kable(file.path(resdir, 'figures/wastats_kable.doc'), self_contained=T)

#Make table of stats for circle intersections
wastats_floodsrc <- setDT(summod(p_attri, mod='BISG', 'last', byc=c('FloodStatus', 'FEMAFloodStatus', 'FEMAStudyStatus')))
gc()
wastats_floodsrc <- wastats_floodsrc[!is.na(V1) & varn=='per',]

wastats_floodsrc_cast <- dcast(wastats_floodsrc, 
                               as.formula(
                                 paste(paste(colnames(wastats_floodsrc)[!(colnames(wastats_floodsrc) %in% c('V1','race'))],collapse = ' + '),'~ race')),
                               value.var = 'V1')

wastats_floodsrc_join <- popstats[wastats_floodsrc_cast, on=.(FloodStatus, FEMAFloodStatus, FEMAStudyStatus)]

#Format table for display
wastats_floodsrc_join[, c('varn','mod'):=NULL]
cols <-  c('white', 'hisp', 'black','asi','oth')
wastats_floodsrc_join[,(cols):=lapply(.SD, function(x) 100*round(x, 2)), .SDcols = cols]
wastats_floodsrc_join[, pop:=round(pop)]
wastats_floodsrc_join <- wastats_floodsrc_join[Venncol, , on=.(FloodStatus, FEMAFloodStatus, FEMAStudyStatus)]

hexpal <- wastats_floodsrc_join[order(-pop), rgb2hex(R,G,B)]
wastats_format <- wastats_floodsrc_join[order(-pop),][,1:(ncol(wastats_floodsrc_join)-3)]
setcolorder(wastats_format, c('FloodStatus', 'FEMAFloodStatus', 'FEMAStudyStatus', 'pop',cols))

kable(wastats_format) %>%
  kable_styling("striped", full_width = F) %>%
  row_spec(1, color = hexpal[1]) %>%
  row_spec(2, color = hexpal[2]) %>%
  row_spec(3, color = hexpal[3]) %>%
  row_spec(4, color = hexpal[4]) %>%
  row_spec(5, color = hexpal[5]) %>%
  row_spec(6, color = hexpal[6]) %>%
  row_spec(1:6, bold=T) %>%
  save_kable(file.path(resdir, 'figures/wastats_kable2.doc'), self_contained=T)

#------------- Construct social vulnerability index at census tract level ----------------------------------------------
#---same as Davies et al. 2018 -  The unequal vulnerability of communities of color to wildfire. PLOS ONE ----------------
# perc.rank function which ignores NAs
perc.rank<- function(x) round(ifelse(is.na(x),NA,rank(x)/sum(!is.na(x))),4) 

# extract relevant columns (estimates as percents for each tract, plus population and per capita income) 
# Updated column name compared to Fire social vulnerability paper. Also note that the US Census Bureau did not
# collect tract level disability data, included in SVI 2000, for either the 2010 Census or the 2006-2010 ACS. 
# Therefore, a disability variable is not included in SVI 2010.
svi_perc<-SVI[,c("FIPS","E_TOTPOP","E_P_POV","E_P_UNEMP","E_P_NOHSDIP","E_P_PCI",
                 "P_AGE65","P_AGE17","P_SNGPRNT","E_P_LIMENG",
                 "E_P_MUNIT","E_P_MOBILE","E_P_CROWD","E_P_NOVEH","P_GROUPQ")]

# find perc.rank of sums of individual perc.ranks; PCI (per capita income) is reversed because higher PCI=lower vulnerability
dropCols = c('FIPS', 'E_TOTPOP', 'EP_PCI')
svi_perc$res_index<-perc.rank(rowSums(
  as.data.frame(lapply(svi_perc[, -which(names(svi_perc) %in% dropCols)], perc.rank)) +
    (1-perc.rank(svi.perc["E_P_PCI"])))) 

#Correlate with flood ratio
t_attri_BISGratiomelt[, race :=  gsub('_BISGs.*', '', variable)]
t_svi_flood <- setDT(svi_perc)[t_attri_BISGratiomelt, on="FIPS==GEOID10_t"]
t_svi_flood <- t_svi_flood[t_attri[, c('GEOID10', 'SUM_PARCELPOP', 'SUM_last_pop', 'SUM_last_popflood'), with=F], on="FIPS==GEOID10"]

multiplot(t_svi_flood[!is.na(race),], 'res_index', 'value', 'SUM_PARCELPOP', 'race')

# join SVI (estimates and margins of error) to tracts
t_svi <- t_attri[svi_perc, on="GEOID10==FIPS"]
mp_cols <- c("FIPS","M_TOTPOP","M_P_POV","M_P_UNEMP","M_P_NOHSDIP","M_P_PCI","M_P_LIMENG","M_P_MUNIT","M_P_MOBILE","M_P_CROWD","M_P_NOVEH")
t_svi <-t_svi[SVI[,mp_cols], on="GEOID10==FIPS"]

# # calculate fire vulnerability
# whp_tract$vuln = sqrt(
#   (whp_tract$res_index - min(whp_tract$res_index, na.rm=T))^2 +
#     ((whp_tract$WHP_avg)/5 - min((whp_tract$WHP_avg/5), na.rm=T))^2) # we divide by 5 to rescale WHP_avg to [0,1]

# standardize fire vulnerability to [0,1]
# whp_tract$vuln = (whp_tract$vuln - min(whp_tract$vuln))/(max(whp_tract$vuln)-min(whp_tract$vuln))


