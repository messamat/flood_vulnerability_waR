library(sf)
library(data.table)
library(plyr)
#library(ggtern)
library(ggplot2)
library(gridExtra)
library(ggrepel)
library(stringr)
library(extrafont)
library(hrbrthemes)
library(VennDiagram)
library(kableExtra)
options(kableExtra.auto_format = FALSE)
library(lme4)
library(rprojroot)
library(fst)
library(patchwork)
library(quantreg)
library(broom)
#library(ggtern) #right now, need to use gglot 

rootdir <- find_root(has_dir("src"))
datadir = file.path(rootdir, 'data')
resdir = file.path(rootdir, 'results')
figdir = file.path(resdir, 'figures')
gdb <- 'flood_risk.gdb'
setwd(resdir)

#+-------------------- Define functions ------------------------------------------------
#Compute percentages for each race for a given model
summod <- function(dt, mod, ref, byc=NULL) {
  races <- unique(gsub(paste0('_',mod,'.*'), '',
                       grep(mod, colnames(dt), value=T)))
  ldply(races, function(race) {
    popcol = grep(paste0(race, '.*', mod, '.*_pop$'), colnames(p_attri), value=T)
    floodcol = grep(paste0(race, '.*', mod, '.*_popflood$'), colnames(p_attri), value=T)
    femacol = grep(paste0(race, '.*', mod, '.*_popFEMA$'), colnames(p_attri), value=T)
    varn <- c('per','floodper','FEMAper')
    statsdt <- p_attri[, c(sum(get(popcol), na.rm=T)/sum(get(paste0(ref, '_pop')), na.rm=T),
                           sum(get(floodcol), na.rm=T)/sum(get(paste0(ref, '_popflood')), na.rm=T),
                           sum(get(femacol), na.rm=T)/sum(get(paste0(ref, '_popfema')), na.rm=T)), by=byc]
    if (is.null(byc)) {
      statsdt <- data.table(bycol=rep('total', length(statsdt)), statsdt)
    }
    statsdt <- cbind(varn, statsdt, race, mod)
    paste0(race,'_',mod,'per')
    return(setDT(statsdt))
  })
}

#Build function for basic multiplot with weighted mean and quantile regression
multiplot <- function(dat, xvar, yvar, weightvar, facetvar) {
  p <- ggplot(dat, aes_string(x=xvar, y=yvar)) + 
    geom_point(alpha=1/4) + 
    #geom_smooth(color='red', method='lm', aes_string(weight = weightvar)) +
    geom_quantile(quantiles=c(0.1, 0.25, 0.5, 0.75, 0.9), color='orange',
                  aes_string(mapping = weightvar)) +
    scale_x_sqrt() +
    geom_hline(yintercept=1, color='blue') +
    facet_wrap(as.formula(paste('~',facetvar)))+ #, scales = 'free_x') +
    theme_classic() +
    theme(axis.title =element_text(size=16),
          strip.text = element_text(size=16),
          strip.background = element_rect(colour="white"),
          text = element_text(size=16))
  print(p)
}

percaxis <- function(x) {
  paste0(round(100*x),'%')
}
#+-------------------- Import data ------------------------------------------------
#Read parcel-level data 
if (file.exists(file.path(resdir, "p_attri.fst"))) {
  print("Reading p_attri.fst")
  p_attri <- read.fst(file.path(resdir, "p_attri.fst")) %>% setDT
} else {
  print("Importing p_attri from gdb, this might take a while...")
  p_attri <- st_read(dsn=gdb,layer="parcel_blocks_fill_flood_attri")
  p_attri <- setDT(p_attri)
  p_attri <- p_attri[FEMAFloodStatus == 1 & is.na(FEMAStudyStatus), FEMAFloodStatus := 0]
  p_attri <- p_attri[is.na(FEMAStudyStatus), FEMAStudyStatus := 0]
  write.fst(p_attri[, -c('Shape')], file.path(resdir, "p_attri.fst"))
}

#Read census block-level analysis data
b_attri <- st_read(dsn=gdb,layer="blockurbanflood_diss")
b_attri <- setDT(b_attri)

#Read census trast-level data
t_attri <- st_read(dsn=gdb, layer="tracts_floodfinal")
t_attri <- setDT(t_attri)

#Read block-group census data
bg <- st_read(file.path(datadir, 'TIGER2017/2010_ACS_5YR_BG_53_WASHINGTON.gdb'), layer = 'ACS_10_5YR_BG_53_WASHINGTON')

#Import SVI data
SVI <- read.csv(file.path(datadir, 'SVI/Washington_03242014.csv'))
SVI$FIPS <- as.factor(SVI$FIPS)

#+-------------------- Format data ---------------------------------------------
labels_full <- c('Non-hispanic White', 'Non-hispanic Black',
                 'Hispanic', 'Non-hispanic API', 'Non-hispanic Other')


#Melt BISG prediction data: % population of each race/ethnicity in each tract)
t_attri_BISGmelt <- melt(t_attri[!is.na(SUM_last_popflood) & SUM_last_popflood>0,], 
                         id.vars = 'GEOID10_t', 
                         measure.vars = grep('BISG_per', colnames(t_attri), value=T)) 
t_attri_BISGmelt[,category := '% of total population']

#Melt BISG prediction data: % population in flood zone of each race/ethnicity in each tract)
t_attri_BISGfloodmelt <- melt(t_attri[!is.na(SUM_last_popflood) & SUM_last_popflood>0,], id.vars = 'GEOID10_t', 
                              measure.vars = grep('BISG_floodper', colnames(t_attri), value=T))
t_attri_BISGfloodmelt[,`:=`(category = '% of population in flood zone',
                            variable = gsub('flood', "", variable))]
t_attri_BISG <- rbind(t_attri_BISGmelt, t_attri_BISGfloodmelt)   %>%
  .[, race := factor(gsub('[_]BISG_.*', '', variable), 
                     levels=c('white', 'black', 'hisp', 'asi', 'oth'), 
                     labels=labels_full)] 

#Melt BISG prediction: flood representativity ratio for each race and tract ()
t_attri_BISGratiomelt <- melt(t_attri[!is.na(SUM_last_popflood) & SUM_last_popflood>0,], 
                              id.vars = 'GEOID10_t', 
                              measure.vars = grep('BISG_floodratio', colnames(t_attri), value=T)) %>%
  .[, race := factor(gsub('[_]BISG_.*', '', variable), 
                     levels=c('white', 'black', 'hisp', 'asi', 'oth'), 
                     labels=labels_full)] %>%
  setnames('value', 'floodratio')

t_attri_BISGratiomelt[, category := ifelse(floodratio<=1, 'negative', 'positive')]


#set up labels
leglabels1 <- c("White population (n.h.)",
                "Hispanic population",
                "Other population (n.h.)",
                "Black population (n.h.)",
                "API population (n.h.)")

#Pre-process parcel-level data
t_attri_ratiomelt <- melt(t_attri[!is.na(SUM_last_popflood) & SUM_last_popflood>0,], id.vars = 'GEOID10_t', 
                          measure.vars = grep('_floodratio', colnames(t_attri), value=T))

p_attri[, urbanrural := ifelse(is.na(NAME10), 'rural', 'urban')] 

wastats_tot <- summod(p_attri, mod='BISG', 'last')
setnames(wastats_tot, 2, 'urbanrural')
wastats <- setDT(rbind(wastats_tot, summod(p_attri, mod='BISG', 'last', byc='urbanrural')))
setnames(wastats, old='V1', new='stats')

wastats[, varn := factor(varn, levels=c('per', 'floodper', 'FEMAper'))] #'FEMAper'
wastats[varn != 'FEMAper',`:=`(segmin_flood = min(stats),
                               segmax_flood = max(stats)), by = .(race, urbanrural)] %>%
  .[varn != 'floodper',`:=`(segmin_FEMA = min(stats),
                            segmax_FEMA = max(stats)), by = .(race, urbanrural)]
wastats$level <- 'parcel'

#Pre-process block-level data
wastats_t <- t_attri[, c(white_censusper = sum(DP0110011)/sum(DP0080001),
                         white_censusfloodper = sum(SUM_FLOODPOP_B*DP0110011/DP0080001, na.rm=T)/sum(SUM_FLOODPOP_B, na.rm=T),
                         white_censusFEMAper = sum(SUM_FEMAPOP_B*DP0110011/DP0080001, na.rm=T)/sum(SUM_FEMAPOP_B, na.rm=T),
                         black_censusper = sum(DP0110012)/sum(DP0080001),
                         black_censusfloodper = sum(SUM_FLOODPOP_B*DP0110012/DP0080001, na.rm=T)/sum(SUM_FLOODPOP_B, na.rm=T),
                         black_censusFEMAper = sum(SUM_FEMAPOP_B*DP0110012/DP0080001, na.rm=T)/sum(SUM_FEMAPOP_B, na.rm=T),
                         hisp_censusper = sum(DP0110002)/sum(DP0080001),
                         hisp_censusfloodper = sum(SUM_FLOODPOP_B*DP0110002/DP0080001, na.rm=T)/sum(SUM_FLOODPOP_B, na.rm=T),
                         hisp_censusFEMAper = sum(SUM_FEMAPOP_B*DP0110002/DP0080001, na.rm=T)/sum(SUM_FEMAPOP_B, na.rm=T),
                         asi_censusper = sum(DP0110014+ DP0110015)/sum(DP0080001),
                         asi_censusfloodper = sum(SUM_FLOODPOP_B*(DP0110014+DP0110015)/DP0080001, na.rm=T)/sum(SUM_FLOODPOP_B, na.rm=T),
                         asi_censusFEMAper = sum(SUM_FEMAPOP_B*(DP0110014+DP0110015)/DP0080001, na.rm=T)/sum(SUM_FEMAPOP_B, na.rm=T),
                         oth_censusper = sum(DP0110013+DP0110016+DP0110017)/sum(DP0110001),
                         oth_censusfloodper = sum(SUM_FLOODPOP_B*(DP0110013+DP0110016+DP0110017)/DP0080001, na.rm=T)/sum(SUM_FLOODPOP_B, na.rm=T),
                         oth_censusFEMAper = sum(SUM_FEMAPOP_B*(DP0110014+DP0110015)/DP0080001, na.rm=T)/sum(SUM_FEMAPOP_B, na.rm=T))]
wastats_tformat <- data.table(stats = wastats_t, 
                              race = gsub('_census.*', '', names(wastats_t)), 
                              varn = gsub('(.*_census)', '', names(wastats_t)))
wastats_tformat[varn != 'FEMAper',`:=`(segmin_flood = min(stats),
                                       segmax_flood = max(stats)), by = race] %>%
  .[varn != 'floodper',`:=`(segmin_FEMA = min(stats),
                            segmax_FEMA = max(stats)), by = race]

wastats_tformat$level <- 'block'

wastats_join <- rbind(wastats, wastats_tformat, fill=TRUE)
wastats_join[, `:=`(varn = factor(varn, levels=c('per', 'floodper', 'FEMAper')), #'FEMAper
                    race = factor(race, levels=unique(setorder(wastats_join[level == 'parcel',], stats)$race)))]
legtitle <- ''
leglabels2 <- c('In total', 'Living in flood zone')
# update_geom_font_defaults(family = "Arial Narrow", face = "plain",
#                           size = 3.5, color = "#2b2b2b")

#+-------------------- Results analysis ------------------------------------------------
#Total number of people
p_attri[,sum(PARCELPOP, na.rm=T)] #Sum of all parcels' population
b_attri[,sum(POP10, na.rm=T)] #Sum of all census blocks' population
#Number of people living within flood zone as predicted with FEMA flood hazard data at census block level
b_attri[,sum(FEMAPOP_B, na.rm=T)]
#Number of people living within flood zone as predicted with FEMA flood hazard data at parcel level
p_attri[,sum(FEMApop, na.rm=T)]
#Number of people living within flood zone as predicted with FATHOM flood hazard data at census block level
b_attri[,sum(FLOODPOP_B, na.rm=T)]
#Number of people living within flood zone as predicted with FATHOM flood hazard data at parcel level
p_attri[,sum(floodpop, na.rm=T)]

#Underestimate with FATHOM-blocks
(p_attri[,sum(floodpop, na.rm=T)]-b_attri[,sum(FLOODPOP_B, na.rm=T)])/p_attri[,sum(floodpop, na.rm=T)]
#Underestimate with FEMA-parcels
(p_attri[,sum(floodpop, na.rm=T)]-p_attri[,sum(FEMApop, na.rm=T)])/p_attri[,sum(floodpop, na.rm=T)]
#Underestimate with FEMA-blocks
(p_attri[,sum(floodpop, na.rm=T)]-b_attri[,sum(FEMAPOP_B, na.rm=T)])/p_attri[,sum(floodpop, na.rm=T)]

#Compute flood ratios at state level
p_attri[,(sum(hisp_BISG_popflood,na.rm=T)/sum(census_popflood,na.rm=T))/
          (sum(hisp_BISG_pop,na.rm=T)/sum(census_pop,na.rm=T))]
p_attri[,(sum(black_BISG_popflood,na.rm=T)/sum(census_popflood,na.rm=T))/
          (sum(black_BISG_pop,na.rm=T)/sum(census_pop,na.rm=T))]
p_attri[,(sum(asi_BISG_popflood,na.rm=T)/sum(census_popflood,na.rm=T))/
          (sum(asi_BISG_pop,na.rm=T)/sum(census_pop,na.rm=T))]
p_attri[,(sum(white_BISG_popflood,na.rm=T)/sum(census_popflood,na.rm=T))/
          (sum(white_BISG_pop,na.rm=T)/sum(census_pop,na.rm=T))]

#+------------- Histogram of total and flood percentage by race + flood ratio, at tract level -----------------------
facet_names1 <- c(
  `white_BISG_per` = "Non-hispanic white population",
  `hisp_BISG_per` = "Hispanic population",
  `black_BISG_per` = "Non-hispanic black population",
  `asi_BISG_per` = "Asian population"
)

ggplot(t_attri_BISG[(variable != c('oth_BISG_per')),]) + 
  geom_histogram(aes(x=value, y = stat(count / sum(count)), fill=category), alpha=1/2, position='identity') +
  scale_x_percent(name = '') + 
  scale_y_percent(name = 'Percent of census tracts') + 
  scale_fill_manual(values = c('#7570b3', '#d95f02'), labels = function(x) str_wrap(x, width = 40)) +
  facet_wrap(~ variable, ncol = 1, scales = "free_y", labeller = as_labeller(facet_names1)) + 
  theme_ipsum_rc() + 
  theme(legend.title = element_blank(),
        legend.position="bottom")

facet_names2 <- c(
  `white_BISG_floodratio` = "Non-hispanic white population",
  `hisp_BISG_floodratio` = "Hispanic population",
  `black_BISG_floodratio` = "Non-hispanic black population",
  `asi_BISG_floodratio` = "Asian population"
)

#Check weighted average of flood ratio
t_attri_BISGcast <- dcast(t_attri_BISG, GEOID10_t+variable~category, value.var = 'value')
setnames(t_attri_BISGcast, old= c('% of population in flood zone','% of total population'), new = c('floodper', 'per'))
t_attri_BISGcast <- t_attri_BISGcast[t_attri, on='GEOID10_t']
t_attri_BISGcast[, `:=`(floodratio = floodper/per,
                        racepop = per*SUM_last_pop)]
#Weighted average of flood ratio by flooded population of each race in bg
t_attri_BISGcast[,sum(floodratio*floodper*SUM_last_popflood, na.rm=T)/sum(floodper*SUM_last_popflood, na.rm=T), by=variable]
#Weighted average of flood ratio by total population of each race in bg
t_attri_BISGcast[,sum(floodratio*racepop, na.rm=T)/sum(racepop, na.rm=T), by=variable]
#Weighted average of flood ratio by total flooded population in bg
t_attri_BISGcast[,sum(floodratio*SUM_last_popflood, na.rm=T)/sum(SUM_last_popflood, na.rm=T), by=variable]
#Weighted average of flood ratio by total population in bg
t_attri_BISGcast[,sum(floodratio*SUM_last_pop, na.rm=T)/sum(SUM_last_pop, na.rm=T),  by=variable]

#+------------- Weighted violin of total and flood percentage by race + flood ratio, at tract level -----------------------

ggplot(t_attri_BISGratiomelt[variable != 'oth_BISG_floodratio',],
       aes(x=variable, y=value, fill=variable, color=variable)) +
  geom_jitter(height = 0, width = 0.1, alpha=1/20, color='black') +
  geom_violin(alpha=1/1.5, draw_quantiles = c(0.25, 0.5, 0.75)) + 
  geom_hline(yintercept=1) + 
  scale_x_discrete(name = '', labels= str_wrap(leglabels1, width=17)) + 
  scale_y_continuous(name = 'Flood risk representativity ratio',
                     limits=c(0,10), breaks = c(0,0.2,0.5,0.8,1,1.25,1.5,2,5, 10)) + 
  scale_fill_discrete(name = 'Flood risk representativity ratio', labels= leglabels1) + 
  scale_color_discrete(name = 'Flood risk representativity ratio', labels= leglabels1) +
  #scale_y_sqrt(breaks = c(0,0.1,0.2,0.5,1,1.5,2,5,10,20,40)) + 
  theme_ipsum_rc() +
  theme(panel.grid.minor = element_blank(),
        legend.position = 'None')

#+------------- Lollipop graphs of total and flood percentage at state level ------------------------------
#+------- Simple summary lollipop graph -------------------------------------
parcel_lollipop <- ggplot(wastats_join[urbanrural %in% c('total',NA) & level=='parcel' & varn != 'FEMAper',]) +
  geom_linerange( aes(x=race, ymin=segmin_flood, ymax=segmax_flood), 
                  color='black') +
  geom_point(aes(x=race, y=stats, color=varn, shape=varn), 
             size=3, alpha=0.9) +
  geom_text_repel(aes(x=race, y=stats, label=paste0(round(100*stats,0),'%'), color=varn),
                  vjust = 0, angle=0,
                  max.iter=20000, direction="x", segment.alpha = 0, xlim = c(0,90), size=4.5) +
  scale_y_continuous(name='% of Washington state population', 
                     labels=percaxis, limits=c(0,0.8), expand=c(0,0)) +
  scale_x_discrete(name = 'Race-Ethnicity',
                    labels= gsub('\\s*population\\s*', '', as.character(rev(leglabels1)))) +
  # #scale_color_manual(name = legtitle, labels= leglabels2, values = c('#8c510a', '#01665e', '#542788')) +
  scale_color_manual(name = legtitle, labels= leglabels2, values = c('#E19F6A', '#68AAE1')) +
  scale_shape(name = legtitle, labels= leglabels2) + 
  coord_flip() +
  theme_bw() +
  theme(legend.position = c(0.65,0.20),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.line = element_line(color='black'),
        text = element_text(size=14),
        plot.margin = unit(c(1 , 1, 1, 1),"cm"))
pdf(file.path(figdir, 'flood_vulnerability_statistics_lollipopgraph.pdf'), width=5, height=4)
parcel_lollipop
dev.off()

#+------- Lollipop graph of total and flood percentage by race x models x parcel vs. block, at state level -----------
parcelblock_lollipop <- ggplot(wastats_join[urbanrural %in% c('total',NA) & varn != 'FEMAper',]) +
  geom_linerange( aes(x=race, ymin=segmin_flood, ymax=segmax_flood, group=level), 
                  color='black', position= position_dodge(width=0.5)) +
  geom_point(aes(x=race, y=stats, color=varn, shape=varn, group=level), 
             size=3, alpha=0.9, position= position_dodge(width=0.5)) +
  #geom_text_repel(aes(x=race, y=stats, label=paste0(round(100*stats,0),'%'), color=varn, group=mod), 
  #                vjust = 0, angle=0, position= position_dodge(width=1.5),
  #                max.iter=20000, direction="x", segment.alpha = 0, xlim = c(0,90)) +
  geom_text(aes(x=race, y=0.45, label=paste0(round(100*stats,0),'%'), color=varn, group=mod), 
                  vjust = 0, angle=0, position= position_dodge(width=1)) +
  annotate('text', x = c(Inf, Inf), y = c(-Inf,-Inf), vjust = c(2,4), hjust = c(-0.05,-0.05),
           label=c('parcel-level assessment', 'block/tract-level assessment')) +
  scale_y_continuous(name='Percentage of the Washington state population', labels=percaxis, limits=c(0,0.9), expand=c(0,0)) +
  scale_x_discrete(name = 'Race-Ethnicity',
                   labels= gsub('\\s*population\\s*', '', as.character(rev(leglabels1)))) +
  #scale_color_manual(name = legtitle, labels= leglabels2, values = c('#8c510a', '#01665e', '#542788')) +
  scale_color_manual(name = legtitle, labels= leglabels2, values = c('#E19F6A', '#68AAE1')) +
  scale_shape(name = legtitle, labels= leglabels2) + 
  coord_flip() +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        panel.border = element_blank(),
        legend.position = c(0.8, 0.20),
        legend.background = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.line = element_line(color='black'),
        text = element_text(size=12),
        plot.margin = unit(c(0.25,0.25,0.25,0.25),"cm"))


urbanrural_lollipop <-ggplot(wastats_join[level == 'parcel' & urbanrural %in% c('rural','urban') & varn != 'FEMAper',]) +
  geom_linerange( aes(x=race, ymin=segmin_flood, ymax=segmax_flood, group=urbanrural), 
                  color='black', position= position_dodge(width=0.5)) +
  geom_point(aes(x=race, y=stats, color=varn, shape=varn, group=urbanrural), 
             size=3, alpha=3/4, position= position_dodge(width=0.5)) +
  #geom_text_repel(aes(x=race, y=stats, label=paste0(round(100*stats,0),'%'), color=varn, group=mod), 
  #                vjust = 0, angle=0, position= position_dodge(width=1.5),
  #                max.iter=20000, direction="x", segment.alpha = 0, xlim = c(0,90)) +
  geom_text(aes(x=race, y=0.45, label=paste0(round(100*stats,0),'%'), color=varn, group=urbanrural), 
            vjust = 0, angle=0, position= position_dodge(width=1)) +
  annotate('text', x = c(Inf, Inf), y = c(-Inf,-Inf), vjust = c(2,4), hjust = c(-0.05,-0.05),
           label=c('Urban areas', 'Rural areas')) +
  scale_y_percent(name='Percentage of the Washington state population', limits=c(0,0.9), expand=c(0,0)) +
  scale_x_discrete(name = 'Race-Ethnicity',
                   labels= gsub('\\s*population\\s*', '', as.character(rev(leglabels1)))) +
  scale_color_manual(name = legtitle, labels= leglabels2, values = c('#8c510a', '#01665e', '#542788')) +
  scale_shape(name = legtitle, labels= leglabels2) + 
  coord_flip() +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        panel.border = element_blank(),
        legend.position = c(0.8, 0.20),
        legend.background = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.line = element_line(color='black'),
        text = element_text(size=12),
        plot.margin = unit(c(0.25,0.25,0.25,0.25),"cm"))


wastats_modformat <- 
  melt(
    wastats_join[level == 'parcel' & urbanrural =='total',
                 .(varn, stats, race, segmin_flood, segmax_flood, segmin_FEMA, segmax_FEMA)],
    id.vars=c('varn', 'stats', 'race')
    ) %>%
  .[, c('seg', 'mod') := tstrsplit(variable, "_", fixed=TRUE)] %>%
  dcast(varn+stats+race+mod~seg, value.var='value') %>%
  .[!is.na(segmin),] %>%
  .[, varn_all := factor(fifelse(varn=='per', 'per', 'flood'),
                         levels=c('per', 'flood'))]


FATHOMFEMA_lollipop <-ggplot(wastats_modformat) +
  geom_linerange( aes(x=race, ymin=segmin, ymax=segmax, group=mod), 
                  color='black', position= position_dodge(width=0.5)) +
  geom_point(aes(x=race, y=stats, color=varn_all, shape=varn_all, group=mod), 
             size=3, alpha=3/4, position= position_dodge(width=0.5)) +
  #geom_text_repel(aes(x=race, y=stats, label=paste0(round(100*stats,0),'%'), color=varn_all, group=mod), 
  #                vjust = 0, angle=0, position= position_dodge(width=1.5),
  #                max.iter=20000, direction="x", segment.alpha = 0, xlim = c(0,90)) +
  geom_text(aes(x=race, y=0.45, label=paste0(round(100*stats,0),'%'), color=varn_all, group=mod), 
            vjust = 0, angle=0, position= position_dodge(width=1)) +
  annotate('text', x = c(Inf, Inf), y = c(-Inf,-Inf), vjust = c(2,4), hjust = c(-0.05,-0.05),
           label=c('Sampson et al. (2017)', 'FEMA')) +
  scale_y_percent(name='Percentage of the Washington state population', limits=c(0,0.9), expand=c(0,0)) +
  scale_x_discrete(name = 'Race-Ethnicity',
                   labels= gsub('\\s*population\\s*', '', as.character(rev(leglabels1)))) +
  scale_color_manual(name = legtitle, labels= leglabels2, values = c('#4d4d4d', '#542788')) +
  scale_shape(name = legtitle, labels= leglabels2) + 
  coord_flip() +
  theme_bw() +
  theme(panel.border = element_blank(),
        legend.position = c(0.8, 0.20),
        legend.background = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.line = element_line(color='black'),
        text = element_text(size=12),
        plot.margin = unit(c(0.25,0.25,0.25,0.25),"cm"))

#png('flood_vulnerability_statistics_lollipopgraph.png', width=12, height=12, units='in', res=400)
pdf(file.path(figdir, 'flood_vulnerability_statistics_lollipopgraph_comparison_centered.pdf'), 
    width=6, height=8)
(parcelblock_lollipop / urbanrural_lollipop / FATHOMFEMA_lollipop)
dev.off()



#Get flood representativity ratio statewide
kable(rbind(wastats_tformat, wastats, fill=T) %>%
        .[is.na(varn), varn := 'FEMAper'] %>%
        dcast( urbanrural+race+level~varn, value.var='stats') %>%
        .[, `:=`(FERRfathom = floodper/per, FEEfema = FEMAper/per)] %>%
        .[is.na(urbanrural), urbanrural := 'total']) %>%
  kable_styling("striped", full_width = F) %>%
  save_kable(file.path(figdir, 'wastats_FERRkable.doc'), self_contained=T)




#+------------- Correlate block-group individual wealth and race indicators to flood ratios ----------------------------------------
colnames(t_attri)

# poverty status B17021e1
# median household income B19013e1
# owner-occupied housing units median value (B25077e1)
# ratio of income to poverty level in past 12 months (C17002e1)
# contract rent/with cash rent (B25056e2)
wastats_bg <- setDT(summod(p_attri, mod='BISG', 'last', byc='GEOID10_bg'))
setnames(wastats_bg, old='V1', new='stats')
wastats_bgj <- wastats_bg[setDT(as.data.frame(bg)[,c('GEOID10', 'B17021e1', 'B19013e1', 'B25077e1', 'C17002e1', 'B25056e2')]),
                         on= 'GEOID10_bg==GEOID10']
wastats_bgj <- wastats_bgj[!is.na(varn),]

#Compute average of state-standardized rent and house prise
wastats_bgj[, `:=`(housing_standardized = B25077e1/mean(B25077e1, na.rm = T),
                  rent_standardized = B25056e2/mean( B25056e2, na.rm = T))]
wastats_bgj[, real_standardized := rowMeans(cbind(housing_standardized, rent_standardized), na.rm=T)]

castf <- as.formula(
  paste(
    paste(colnames(wastats_bgj)[!(colnames(wastats_bgj) %in% c('varn','value', 'variable', 'stats'))], collapse = ' + '),
    '~ varn'))

wastats_bgcast <- dcast(wastats_bgj, castf, value.var = 'stats')
wastats_bgcast[, floodratio := floodper/per] #FEMAratio = FEMAper/per

#Check distribution of block group's total population and each race's population
wastats_bgcast <- wastats_bgcast[setDT(bg)[, c('GEOID10', 'B01001e1'), with=FALSE], on='GEOID10_bg==GEOID10']
wastats_bgcast <- wastats_bgcast[p_attri[, .(last_pop = sum(last_pop, na.rm=T),
                                             last_popflood = sum(last_popflood, na.rm=T),
                                             last_poper = sum(last_popflood, na.rm=T)/sum(last_pop, na.rm=T)),
                                         by='GEOID10_bg'], on='GEOID10_bg']
wastats_bgcast[, racepop := per*last_pop]
wastats_bgcast <- wastats_bgcast[!is.na(race),]

ggplot(wastats_bgcast, aes(x=racepop)) + 
  geom_histogram() + 
  scale_y_log10() +
  scale_x_continuous(breaks = seq(0,4000,200)) +
  facet_wrap(~race, nrow=5) +
  theme_ipsum()

#Distribution of population count/block group
ggplot(bg, aes(x=B01001e1)) + 
  geom_histogram() + 
  scale_y_log10() +
  scale_x_continuous(breaks = seq(0,4000,200)) +
  theme_ipsum()

#Weighted average of flood ratio by flooded population of each race in bg
wastats_bgcast[,sum(floodratio*floodper*last_popflood, na.rm=T)/sum(floodper*last_popflood, na.rm=T), by='race']
wastats_bgcast[,sum(floodper*last_popflood, na.rm=T), by=c('race')]
#Weighted average of flood ratio by total population of each race in bg
wastats_bgcast[,sum(floodratio*racepop, na.rm=T)/sum(racepop, na.rm=T), by='race']
#Weighted average of flood ratio by total flooded population in bg
wastats_bgcast[,sum(floodratio*last_popflood, na.rm=T)/sum(last_popflood, na.rm=T), by='race']
#Weighted average of flood ratio by total population in bg
wastats_bgcast[,sum(floodratio*last_pop, na.rm=T)/sum(last_pop, na.rm=T), by='race']

#Check correlation with percentage population of each race in block group
multiplot(wastats_bgcast[racepop != 0,], 
          xvar='per', yvar='floodratio', weightvar='racepop', facetvar = 'race')

#Check correlation with percentage population in flood zone in block group
multiplot(wastats_bgcast[racepop != 0,], 
          xvar='last_poper', yvar='floodratio', weightvar='racepop', facetvar = 'race')

#Check correlation with median household income (B19013e1)
multiplot(wastats_bgcast[racepop != 0,],
          xvar='B19013e1', yvar='floodratio', weightvar='racepop', facetvar = 'race')

#Check correlation with ratio of income to poverty level in past 12 months
multiplot(wastats_bgcast[racepop != 0,],
          xvar='C17002e1', yvar='floodratio', weightvar='racepop', facetvar = 'race')

#Check correlation with real estate standardized index 
#(average of statewide-standardized rent and house prices)
multiplot(wastats_bgcast[racepop != 0,],
          xvar='real_standardized', yvar='floodratio', weightvar='racepop', facetvar = 'race')

#+------------- Venn diagram of FATHOM and FEMA analysis --------------------------------------------------------------
Venn <- FALSE
if (Venn) {
  popstats <- p_attri[,sum(PARCELPOP, na.rm=T), by=c('FloodStatus', 'FEMAFloodStatus', 'FEMAStudyStatus')]
  setnames(popstats, 'V1', 'pop')
  
  #FEMA study - FEMA flood Venn
  grid.newpage()
  draw.pairwise.venn(round(popstats[FEMAStudyStatus==1, sum(pop)])/1000,
                     round(popstats[FEMAFloodStatus==1, sum(pop)])/1000,
                     round(popstats[FEMAFloodStatus==1, sum(pop)])/1000,
                     category = c("Population within FEMA-assessed area",
                                  "Population within FEMA flood zone"),
                     lty = rep("blank",2),
                     fill = c("light blue", "darkblue"),
                     alpha = rep(0.5, 2),
                     cat.pos = c(0,0),
                     cat.dist = rep(0.025, 2))
  
  #FEMA flood- FATHOM flood Venn
  grid.newpage()
  draw.pairwise.venn(round(popstats[FEMAFloodStatus==1, sum(pop)])/1000,
                     round(popstats[FloodStatus==1, sum(pop)])/1000,
                     round(popstats[FloodStatus==1 & FEMAFloodStatus==1, sum(pop)])/1000,
                     category = c("Population within FEMA flood zone",
                                  "Population within FATHOM flood zone"),
                     lty = rep("blank",2),
                     fill = c("light blue", "darkblue"),
                     alpha = rep(0.5, 2),
                     cat.pos = c(0,0),
                     cat.dist = rep(0.025, 2))
  
  #FEMA study - FATHOM flood
  grid.newpage()
  draw.pairwise.venn(round(popstats[FEMAStudyStatus==1, sum(pop)])/1000,
                     round(popstats[FloodStatus==1, sum(pop)])/1000,
                     round(popstats[FloodStatus==1 & FEMAStudyStatus==1, sum(pop)])/1000,
                     category = c("Population within FEMA-assessed area",
                                  "Population within FATHOM flood zone"),
                     lty = rep("blank",2),
                     fill = c("light blue", "darkblue"),
                     alpha = rep(0.5, 2),
                     cat.pos = c(0,0),
                     cat.dist = rep(0.025, 2))
  
  #Make table of stats for full circles (e.g. all population in FATHOM flood zone vs not)
  fullkablestats <- function(col) {
    stats <- setDT(summod(p_attri, mod='BISG', 'last', byc=col))
    stats2 <- dcast(stats[varn=='per',], get(col)~race, value.var = 'V1')
    popstats <- p_attri[,.(pop = sum(PARCELPOP, na.rm=T)), by=col]
    stats2 <- stats2[popstats, on=paste0('col==',col)]
    stats2$varn <- col
    return(stats2)
  }
  
  allstats <- setDT(summod(p_attri, mod='BISG', 'last', byc=NULL))
  allstats_format <- cbind(col='1',
                           dcast(allstats[varn=='per',], varn~race, value.var = 'V1'),
                           pop=p_attri[, sum(PARCELPOP, na.rm=T)])
  allstats_format[,(cols):=lapply(.SD, function(x) 100*round(x, 2)), .SDcols = cols]
  allstats_format[, pop:=round(pop)]
  setcolorder(allstats_format, c('varn','col','pop',cols))
  
  wastats_floodsrc2 <- rbind(fullkablestats('FEMAStudyStatus'),
                             fullkablestats('FEMAFloodStatus'),
                             fullkablestats('FloodStatus'))
  wastats_floodsrc2[,(cols):=lapply(.SD, function(x) 100*round(x, 2)), .SDcols = cols]
  wastats_floodsrc2[, pop:=round(pop)]
  setcolorder(wastats_floodsrc2, c('varn','col','pop',cols))
  
  kable(rbind(allstats_format, wastats_floodsrc2)) %>%
    kable_styling("striped", full_width = F) %>%
    save_kable(file.path(resdir, 'figures/wastats_kable.doc'), self_contained=T)
  
  #Make table of stats for circle intersections
  wastats_floodsrc <- setDT(summod(p_attri, mod='BISG', 'last', byc=c('FloodStatus', 'FEMAFloodStatus', 'FEMAStudyStatus')))
  gc()
  wastats_floodsrc <- wastats_floodsrc[!is.na(V1) & varn=='per',]
  
  wastats_floodsrc_cast <- dcast(wastats_floodsrc,
                                 as.formula(
                                   paste(paste(colnames(wastats_floodsrc)[!(colnames(wastats_floodsrc) %in% c('V1','race'))],collapse = ' + '),'~ race')),
                                 value.var = 'V1')
  
  wastats_floodsrc_join <- popstats[wastats_floodsrc_cast, on=.(FloodStatus, FEMAFloodStatus, FEMAStudyStatus)]
  
  #Format table for display
  wastats_floodsrc_join[, c('varn','mod'):=NULL]
  cols <-  c('white', 'hisp', 'black','asi','oth')
  wastats_floodsrc_join[,(cols):=lapply(.SD, function(x) 100*round(x, 2)), .SDcols = cols]
  wastats_floodsrc_join[, pop:=round(pop)]
  wastats_floodsrc_join <- wastats_floodsrc_join[Venncol, , on=.(FloodStatus, FEMAFloodStatus, FEMAStudyStatus)]
  
  hexpal <- wastats_floodsrc_join[order(-pop), rgb2hex(R,G,B)]
  wastats_format <- wastats_floodsrc_join[order(-pop),][,1:(ncol(wastats_floodsrc_join)-3)]
  setcolorder(wastats_format, c('FloodStatus', 'FEMAFloodStatus', 'FEMAStudyStatus', 'pop',cols))
  
  kable(wastats_format) %>%
    kable_styling("striped", full_width = F) %>%
    row_spec(1, color = hexpal[1]) %>%
    row_spec(2, color = hexpal[2]) %>%
    row_spec(3, color = hexpal[3]) %>%
    row_spec(4, color = hexpal[4]) %>%
    row_spec(5, color = hexpal[5]) %>%
    row_spec(6, color = hexpal[6]) %>%
    row_spec(1:6, bold=T) %>%
    save_kable(file.path(resdir, 'figures/wastats_kable2.doc'), self_contained=T)
}

#+------------- Quantile regression of social vulnerability index at census tract level -----------------------------------
#+------- Compute Adaptive Capacity and SVI ------------------------------------
perc.rank<- function(x) round(ifelse(is.na(x),NA,rank(x)/sum(!is.na(x))),4) #perc.rank function which ignores NAs

# extract relevant columns (estimates as percents for each tract, plus population and per capita income) 
# Updated column name compared to Fire social vulnerability paper. Also note that the US Census Bureau did not
# collect tract level disability data, included in SVI 2000, for either the 2010 Census or the 2006-2010 ACS. 
# Therefore, a disability variable is not included in SVI 2010.
svi_perc<-SVI[,c("FIPS", #Unique identifier for each census tract
                 "E_TOTPOP", #Total population
                 "E_P_POV", #% individuals below poverty (ACS)
                 "E_P_UNEMP", #Percent civilian unemployed (ACS)
                 "E_P_NOHSDIP", #Percent persons with no high school diploma (ACS)
                 "E_P_PCI", #Per capita income estimate (ACS)
                 "P_AGE65", #% persons 65 years of age or older (Full census)
                 "P_AGE17", #% persons 17 years of age or younger (Full census)
                 "P_SNGPRNT", #% single parent households with children under 18 (Full census)
                 "E_P_LIMENG", #Proportion of person (age 5+) who speak English "less than well" estimate
                 "E_P_MUNIT", #Proportion of housing in structures with 10 or more units estimate
                 "E_P_MOBILE", #Proportion of mobile homes estimate
                 "E_P_CROWD", #Propotion of households with more people than rooms estimate
                 "E_P_NOVEH", #Proportion of households with no vehicle available estimate
                 "P_GROUPQ")] #Proportion of persons in institutionalized group quarters

# find perc.rank of sums of individual perc.ranks; PCI (per capita income) is reversed because higher PCI=lower vulnerability
dropCols = c('FIPS', 'E_TOTPOP', 'EP_PCI')
svi_perc$res_index<-perc.rank(rowSums(
  as.data.frame(lapply(svi_perc[, -which(names(svi_perc) %in% dropCols)], perc.rank))) +
    (1-perc.rank(svi_perc["E_P_PCI"])))

#Check distribution of svi to make sure it's right
qplot(svi_perc$res_index)

#Compute SVI
t_svi <- setDT(svi_perc[,c('FIPS', 'res_index')])[t_attri_BISG, on="FIPS==GEOID10_t"] %>% #Warning is fine 
  dcast(formula = FIPS+res_index+race+variable~category, value.var='value') %>% 
  .[t_attri[, c('GEOID10', 'SUM_PARCELPOP', 'SUM_last_pop', 'SUM_last_popflood'), with=F], on="FIPS==GEOID10"]

t_svi[, V := sqrt((res_index-min(res_index, na.rm=T))^2 + (`SUM_last_popflood`/`SUM_PARCELPOP`)^2)]
summary(t_svi)

#+------- Plot it --------------------------------------------------------------
#Correlate with flood ratio
str(t_attri_BISGratiomelt)
str(svi_perc)
t_svi_flood <- setDT(svi_perc)[t_attri_BISGratiomelt, on="FIPS==GEOID10_t"] %>% #Warning is fine
  .[t_attri[, c('GEOID10', 'SUM_PARCELPOP', 'SUM_last_pop', 'SUM_last_popflood'), with=F], on="FIPS==GEOID10"]

p <- ggplot(t_svi_flood, aes(x=floodratio, y=res_index)) + 
  geom_point(alpha=1/4) + 
  geom_quantile(quantiles=c(0.1, 0.25, 0.5, 0.75, 0.9), color='black',
                aes(mapping = SUM_PARCELPOP)) +
  # geom_quantile(quantiles=c(0.1, 0.25, 0.5, 0.75, 0.9), color='orange',
  #               aes(mapping = SUM_PARCELPOP)) +
  scale_x_sqrt() +
  #geom_hline(yintercept=1, color='blue') +
  facet_wrap(~race)+ #, scales = 'free_x') +
  theme_classic() +
  theme(axis.title =element_text(size=16),
        strip.text = element_text(size=16),
        strip.background = element_rect(colour="white"),
        text = element_text(size=16))
print(p)


#Correlate with proportion within census tract
p_vpopper <- ggplot(t_svi[!is.na(race),], aes(x=100*`% of total population`, y=V)) + 
  geom_point(alpha=1/6, aes(size=SUM_PARCELPOP)) + 
  #geom_smooth(color='red', method='lm', aes_string(weight = weightvar)) +
  geom_quantile(quantiles=c(0.1, 0.5, 0.9), color='black',
                aes(mapping = SUM_PARCELPOP)) +
  scale_x_sqrt(name = "% of total population", limits=c(0,100), expand=c(0,0), breaks=c(0,10,25,50,75,100)) +
  scale_y_continuous(name = 'Vulnerability index', limits=c(0,1.5), expand=c(0,0)) +
  scale_radius(range=c(1, 5), name='Total population') + 
  #geom_hline(yintercept=1, color='black') +
  facet_wrap(~race, scales = 'free_x', labeller=label_value) +
  coord_cartesian(clip='off') +
  theme_classic() +
  theme(axis.title =element_text(size=10),
        axis.text = element_text(size=10),
        strip.text = element_text(size=10),
        strip.background = element_rect(colour="white"),
        text = element_text(size=10))
png(filename = file.path(resdir, 'figures', paste0('scatterplot_VIpopper', Sys.Date(), '.png')), 
    width=6, height=6, unit='in', res=600)
print(p_vpopper)
dev.off()

#+------- Get QR coefficients table --------------------------------------------
t_svi[, `% of total population_100` := 100*`% of total population`]
coefcols <- c('estimate', 'conf.low', 'conf.high')

multi_rqfit <- t_svi[!is.na(race), 
                     c(tidy(rq(V ~ `% of total population_100`,
                                  weights = SUM_PARCELPOP,
                                  tau = c(0.1, 0.5, 0.9)),
                            conf.int=FALSE)
                       ),
                     by=race] %>%
  .[, term := gsub('[`]|[(]|[)]|_100', '', term)] %>%
  .[, (coefcols) := lapply(.SD, function(x) round(x, 3)), 
    .SDcols = coefcols] %>%
  setnames('race', 'race/ethnicity') %>%
  setorder('race/ethnicity', 'term', 'tau') %>%
  melt(id.vars=c('race/ethnicity', 'term','tau')) %>%
  dcast(term+tau~`race/ethnicity`, 
        fun.agg = function(x) paste(x, collapse=','),
        value.var='value') %>%
  .[, (labels_full) := 
      lapply(.SD, function(x) sub('^[-]*[01][.][0-9]*\\K[,]', '\n(', x, perl=T)),
    .SDcols = labels_full] %>%
  .[, (labels_full) := 
      lapply(.SD, function(x) sub('$', ')', x, perl=T)),
    .SDcols = labels_full]

print(multi_rqfit)


kable(multi_rqfit) %>%
kable_styling("striped", full_width = F)%>%
  save_kable(file.path(figdir, 'wastats_QR_SVI.doc'), self_contained=T)


#Get model predictions
taucols <-  c('t01', 't05', 't09')
rqpreds <- t_svi[!is.na(race), 
                 c(predict(
                   rq(V ~ `% of total population_100`,
                      weights = SUM_PARCELPOP,
                      tau = c(0.1, 0.5, 0.9)),
                   newdata=data.table(`% of total population_100`=seq(0,100,5)))),
                 by=race] %>%
  .[, `:=`(tau = rep(rep(c(0.1, 0.5, 0.9), each=21), 5),
           popper = rep(rep(seq(0,100,5), 3), 5))] %>%
  dcast(race+popper~tau, value.var='V1')
print(rqpreds)

dcast(rqpreds, race~popper, value.var='0.5') %>%
  .[, 100*(`75`-`25`)/`25`]


#+------- Examine and plot role of flood exposure vs. AC -----------------------
t_svi[!is.na(race),
      perpop_relmax := ((`% of total population`-min(`% of total population`))/
                          (max(`% of total population`)-min(`% of total population`))),
      by = race]
t_svi[!is.na(race), floodper_total := `SUM_last_popflood`/`SUM_PARCELPOP`]


plot_ACraceper <- ggplot(t_svi[!is.na(race),], aes(x = 100*`% of total population`,
                                           y = (100*res_index))) + 
  geom_point(alpha=1/4, aes(size=SUM_PARCELPOP), color = '#68AAE1') + 
  geom_quantile(quantiles=c(0.1, 0.5, 0.9), color='black',
                aes(mapping = SUM_PARCELPOP)) +
  #geom_smooth(span=1, color='black') +
  scale_x_sqrt(expand=c(0,0), limits=c(0,100), name = "Normalized % of total population",
               breaks = c(0, 25, 50, 100)) + 
  scale_y_sqrt(expand=c(0,0), limits=c(0,100), name = "Adaptive capacity",
               breaks = c(0, 10, 25, 50, 75, 100)) + 
  scale_size_continuous(name='Tract population', breaks = c(2500,5000,12500)) +
  coord_cartesian(clip='off') + 
  facet_grid(~race) + 
  theme_classic() + 
  theme(text=element_text(size=10),
        axis.title.y = element_text(margin = margin(t = 0, r = -1, b = 0, l = 0)),
        legend.position = c(0.08,0.17),
        legend.background = element_blank(),
        legend.title = element_text(size=7.5),
        legend.text = element_text(size=7.5),
        legend.key.height = unit(0.2, 'cm'),
        panel.spacing = unit(0.75, "lines"),
        axis.title.x = element_blank())

plot_floodraceper <- ggplot(t_svi[!is.na(race),], aes(x = 100*`% of total population`,
                                                      y = 100*`SUM_last_popflood`/`SUM_PARCELPOP`)) + 
  geom_point(alpha=1/4, aes(size=SUM_PARCELPOP), color = '#68AAE1') + 
  geom_quantile(quantiles=c(0.1, 0.5, 0.9), color='black',
                aes(mapping = SUM_PARCELPOP)) +
  #geom_smooth(span=1, color='black') +
  scale_x_sqrt(expand=c(0,0), limits=c(0,100), name = "Normalized % of total population",
               breaks = c(0,25, 50, 100)) + 
  scale_y_sqrt(expand=c(0,0), limits=c(0,100), name = "% population exposed to flooding",
               breaks = c(0, 10, 25, 50, 75, 100)) + 
  coord_cartesian(clip='off') + 
  facet_grid(~race) + 
  theme_classic() +
  theme(text=element_text(size=10),
        axis.title.y = element_text(margin = margin(t = 0, r = -1, b = 0, l = 0)),
        legend.position='none',
        panel.spacing = unit(0.75, "lines"),
        strip.background = element_blank(),
        strip.text = element_blank()
  )

png(filename = file.path(resdir, 'figures', paste0('scatterplot_ACfloodper', Sys.Date(), '.png')), 
    width=6.5, height=6, units='in', res=600)
plot(grid.arrange(plot_ACraceper, plot_floodraceper))
dev.off()



#Try other plotting options
ggplot(t_svi[!is.na(race),], aes(x = `SUM_last_popflood`/`SUM_PARCELPOP`,
                                 y = res_index,
                                 color = perpop_relmax)) + 
  geom_point(aes(size=SUM_PARCELPOP)) +
  scale_color_distiller(palette='Spectral') + 
  facet_grid(~race)

ggtern::ggtern(data=as.data.frame(t_svi[!is.na(race),]),
               mapping = aes(x=res_index, y=floodper_total, z=`% of total population`)) +
  geom_point() + 
  facet_wrap(~race)+
  theme_rgbw() +
  theme_showarrows() 




